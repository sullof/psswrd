const path = require('path')
const pkg = require('../package')
const fs = require('./utils/fs')
const Crypto = require('./utils/Crypto')
const Items = require('./models/Items')
const db = require('./utils/Db')
const {status, errors} = require('./constants')

const HEX_REGEX = /^[0-9a-f]$/
const BASE64_REGEX = /^[A-Za-z0-9+/]+={0,2}$/
const PSSWRD_PATH = path.join(process.env.HOME, '.psswrd')
const DEFAULT_STORE = 'default_store'

class Psswrd {

  constructor() {
    this.db = db
    this.rootdir = process.env.NODE_ENV === 'test'
        ? path.resolve(__dirname, '../tmp/.psswrd')
        : PSSWRD_PATH
    this.db.init(path.join(this.rootdir, 'data'))
    this.status = status.CONSTRUCTED
  }

  init() {
    if (this.status === status.CONSTRUCTED && !this.initializingNow) {
      this.initializingNow = true
      return Promise.resolve()
          .then(() => {

            if (fs.existsSync(this.rootdir)) {
              return Promise.resolve()
            } else {
              return fs.ensureDirAsync(this.rootdir)
                  .then(() => {
                    return fs.writeFileAsync(path.join(this.rootdir, 'README'), `
This folder has been generated by psswrd v${pkg.version}.
It contains your secret's database. 
Be careful and don't touch anything!
`, 'utf-8')
                  })
            }
          })
          .then(() => {
            this.db.init(path.join(this.rootdir, 'data'))
            this.index = new Items(this.db)
            this.status = status.INITIALIZED
            delete this.initializingNow
            return this.getMasterKey()
          })
          .catch(err => delete this.initializingNow)
    } else if (this.status === status.INITIALIZED) {
      return this.getMasterKey()
    } else {
      return Promise.resolve()
    }
  }

  getMasterKey() {
    return this.db.get('masterKey')
        .then(key => {
          if (key) {
            this.encryptedMasterKey = key
            this.status = status.READY
          }
          return Promise.resolve()
        })
  }

  gitInit(remoteRepo) {
    // TODO
    // associate the store to a remote repo
    return Promise.resolve()
        .then(() => {

          if (fs.existsSync(path.join(this.rootdir, '.git'))) {
            // repo exists
            throw new Error(errors.RepoExists)
          } else {
            // associate the remoteRepo

            return Promise.resolve()
          }
        })
  }

  allowLogin() {
    return this.status === status.READY
  }

  login(userPassword) {
    if (this.allowLogin()) {
      return Crypto.fromAES(this.encryptedMasterKey, userPassword)
          .then(key => {
            this.index = new Items(db)
            return this.index.init(key)
          })
    } else {
      throw new Error(errors.NotReady)
    }
  }

  allowSignup() {
    return this.status === status.INITIALIZED
  }

  signup(password) {
    let masterKey
    if (this.allowSignup()) {
      return Crypto.getRandomString(40)
          .then(randomString => {
            masterKey = randomString
            return Crypto.toSHA256(password, 'psswrd')
          })
          .then(hashedPassword => Crypto.toAES(masterKey, hashedPassword))
          .then(encryptedMasterKey => this.db.put('masterKey', encryptedMasterKey))
          .then(() => this.index.init(masterKey))
    } else {
      throw new Error(errors.NotInitialized)
    }
  }

}

module.exports = new Psswrd