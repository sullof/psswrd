const path = require('path')
const pkg = require('../package')
const fs = require('./utils/fs')
const Crypto = require('./utils/Crypto')
const Manifest = require('./models/Manifest')
const Secret = require('./models/Secret')
const db = require('./utils/Db')
const {status, errors, keys} = require('./config/constants')

class Psswrd {

  constructor() {
    this.db = db
    this.rootdir = process.env.NODE_ENV === 'test'
        ? path.resolve(__dirname, '../tmp/.psswrd')
        : path.join(process.env.HOME, '.psswrd')
    this.db.init(path.join(this.rootdir, 'database'))
    this.status = status.CONSTRUCTED
  }

  init() {
    if (this.status === status.CONSTRUCTED && !this.initializingNow) {
      this.initializingNow = true
      return Promise.resolve()
          .then(() => fs.ensureDirAsync(this.rootdir))
          .then(() => {
            const readmePath = path.join(this.rootdir, 'README')
            if (!fs.existsSync(readmePath)) {
              return fs.ensureDirAsync(this.rootdir)
                  .then(() => {
                    return fs.writeFileAsync(path.join(this.rootdir, 'README'), `
This folder has been generated by psswrd v${pkg.version}.
It contains your secret's database. 
Be careful and don't touch anything!
`, 'utf-8')
                  })
            }
            else return Promise.resolve()

          })
          .then(() => {
            this.db.init(path.join(this.rootdir, 'database'))
            this.manifest = new Manifest(this.db)
            this.status = status.INITIALIZED
            delete this.initializingNow
            return this.getMasterKey()
          })
          .catch(err => delete this.initializingNow)
    } else if (this.status === status.INITIALIZED) {
      return this.getMasterKey()
    } else {
      return Promise.resolve()
    }
  }

  getMasterKey() {
    return this.db.get(keys.MASTERKEY)
        .then(key => {
          if (key) {
            this.encryptedMasterKey = key
            this.status = status.READY
          }
          return Promise.resolve()
        })
  }

  gitInit(remoteRepo) {
    // TODO
    // associate the store to a remote repo
    return Promise.resolve()
        .then(() => {

          if (fs.existsSync(path.join(this.rootdir, '.git'))) {
            // repo exists
            return Promise.reject(errors.RepoExists)
          } else {
            // associate the remoteRepo

            return Promise.resolve()
          }
        })
  }

  isReady() {
    return this.status === status.READY
  }

  login(password) {
    if (this.isReady()) {
      return Crypto.toSHA256(password, 'psswrd')
          .then(hashedPassword => Crypto.fromAES(this.encryptedMasterKey, hashedPassword))
          .then(key => {
            this.manifest = new Manifest(db)
            return this.manifest.init(key)
          })
          .then(() => Promise.resolve(this.status = status.OPERATIVE))
    } else {
      return Promise.reject(errors.NotReady)
    }
  }

  isInitiated() {
    return this.status === status.INITIALIZED
  }

  signup(password) {
    let masterKey
    if (this.isInitiated()) {
      return Crypto.getRandomString(32)
          .then(randomString => {
            masterKey = randomString
            return Crypto.toSHA256(password, 'psswrd')
          })
          .then(hashedPassword => Crypto.toAES(masterKey, hashedPassword))
          .then(encryptedMasterKey => {
            this.encryptedMasterKey = encryptedMasterKey
            this.status = status.READY
            return this.db.put(keys.MASTERKEY, encryptedMasterKey)
          })
          .then(() => this.manifest.init(masterKey))
          .then(() => Promise.resolve(this.status = status.OPERATIVE))
    } else {
      return Promise.reject(errors.NotInitialized)
    }
  }

  isOperative() {
    return this.status === status.OPERATIVE
  }

  newOrUpdateSecret(options) {
    return this.manifest.newOrUpdateSecret(options)
  }

  onClose() {
    this.manifest.onClose()
    delete this.manifest
    delete this.db
  }

}

module.exports = new Psswrd